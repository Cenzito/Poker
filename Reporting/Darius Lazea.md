Week 1  (20/11 -26/11)
Learning to merge a branch
Researched an option to implement a bot, using Monte-Carlo simulations to find an approximate of the winning rate, then making an optimal bet using Kelly's criterion having that approximate winning rate. Quite a solid play, but it does not take into account other players behaviour.

Week 2 (27/11 - 4/12)
 Added implementations for basic functionalities of the player class (in the logic branch). Commented code, added a file for documenting how we implement some aspects of the project (data attributes used, so that other people can start working on their part).
 Commented some code, rewrote the suit attribute of the Card class (to make everything more readable and easier to work with).
 Reimplemented some of the functions of the card class using this new attribute, integrated the changes on the Deck class. Added code lines for testing our methods in the main.cpp
 Had quite an adventure making the code run on VS code.

 Week 3 (5/12- 11/12)
 Created and implemented the PokerHand class. A PokerHand is just an object containing a vector of cards, and then implemented some member functions to it. Some of them were helping functions in implementing the characteristic functions that check if any specific poker combination can be formed using the cards in the hand. All of these culminated with the compute_score function, that creates a score for each hand, scoring the best poker combination that is contained in the hand as well as numerical score for all kickers to settle draws. The function compare_hands has the ultimate goal, it takes two hands and determines the winner (or determines if we have a draw) and will be used to playing the game. Created lots of test cases in main.cpp and some random hands, getting good results. Also, added lots of comments and tried to make everything as readable as possible.

 week 4 (11/12 - 18/12 )
 Started working on the computer of the winning probability of a winning hand. Using Monte-Carlo simulation, the function takes as input the number of players, the cards in hand and the state of the game (the available community cards) and simulates a number of games to get the rough winning probability (it returns a vector with 3 floats, the winning/tie/losing probabilities). I ran into some issues running it, and got a lot of bugs, so it was unrunable during this state of the project. Also, further worked into documeting the code we are writing on the google docs on Trello. 

Week 5 (18/12- 24/12)

Finalised the winning probability calculator. I solved all of the bugs (most of them were initialization issues that led to out-of-bound vector errors), but then got some absurd results (only ties or wins after a certain point), so I did a lot of testing to pinpoint the issues (and then commented some of the prints I used but left them in the code if any further problem appears). Found some logic issues that I fixed, now it returns robust results. It has a decent runtime (under 5 seconds for 10000 trials given 4 other players, should be enough to get the bot to make a computation of the winning probability within 2% accuracy in his given time). Then, I began implementing some of the basic stuff in my bot (constructor, the action function). To make the bot runable it remains to implement the function that takes the current wealth and state of the table into account and computes the optimal bet amount, using Kelly's criterion.

Week 6 (8/1 -14/1)
This week was mostly dedicated to understanding the mathematical intricanses of the Kelly's criterion and the possible uses of it in my bot. Since Kelly's criterion uses as a factor in determining the optimal bet the odds a certain bet has, which is uncomputable due to the big number of factors in poker, I needed a different approach. I rewrote Kelly's criterion using algebraic substitutions and computations to obtain a quite different form, then I assumed (as a first step), that a player expects to win just the pot that is currently on the table (does not take into account that other players might check increasing the expected win) so it should play more conservatively. Still, some odd situations might appear were the bot, given this strategy, is not playing optimally at all, situations we cannot control for. Left more comments about this specificially in the commits.

Week 7 (15/1 -21/1)

Started with some modifications of the bot, that integrated some new aspects made in the Table function, namely the action functions, done for the purpose of a player communicating it's decision regarding raising, calling, folding. Then updated the winning_probability_function so that it takes as an atribute a vector of cards, not a player, so that we can use it more easily. Also, in the winning_probability_function I used passing by reference which significantly speed up the function timing, which is esential for getting the estimates accurate. Created a function in the bot function that finds out the number of chips a particular player has (for some reason this is not anymore an attribute of the PokerPlayer class), and finally merged the winning_proba function into BotDarius, so I can modify my bot accordingly to these changes and have both updates integrated on main at the same time.

Week 8 (22/1 - 27/1)
Started by debugging with Remi some problems with my bot, that went into an infinite loop. There was a missing i++; at the end of a while loop in find_stack_size. Then we tested the bot and saw that it is too cautios sometimes, so I build something a little bit more intricate, by considering some very broad approximations of the expected win. Changed some mistakes regarding the logical aspect of the bot (it considered too many players when computing the expected win ration, since active_players() also considers the bot as an active player). Also, I added references to speed up the code in some parts. Now, I will treat the case if the bot begins as the big_blind, because I saw some shortcomings in that area.
Finished documenting the code for the logical part of the project, and added comments where was the case across the code. 
